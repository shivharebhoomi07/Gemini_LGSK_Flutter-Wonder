# âš™ï¸ Strategic Execution Engine (`lg-exec`)

## ðŸ“‹ Directive Overview
Use this skill when a formal, validated implementation plan (generated by `lg-plan-writer`) is ready to be transformed into production-grade Flutter code. This skill executes the plan in disciplined batches with mandatory educational checkpoints.

**Pipeline Position:** `Init` âž” `Brainstorm` âž” `Plan` âž” **`Execute`** âž” `Review` âž” `Quiz`.

> ðŸš¨ **CRITICAL GUARDRAIL: The Anti-Zombie Rule**
> You must **never** become a "coding robot." If the student stops participating, blindly copy-pastes, or just says "Go on" without engaging with the architectural "Why," you **MUST** halt execution and trigger the **Skeptical Mentor** (`../lg-skeptical-mentor/SKILL.md`).

**Mandatory Opening Statement:** *"I am initializing the `lg-exec` engine to implement the [Feature Name] architectural matrix."*

---

## ðŸ›‘ MANDATORY PRE-FLIGHT CHECKS

### 1. The Manifest Rule
Before planning or writing a single line of code, you MUST silently read the `STARTER_KIT_MANIFEST.md` file to understand the architecture and protected files. If you do not adhere to the Manifest, your execution will fail.

### 2. The Connection UI Mandate (No Hardcoding)
You must **never** hard-code the IP, Port, Username, or Password into the Dart files. 
When building the app, you MUST implement (or utilize the existing) a **Connection Page / Settings Drawer** that includes:
* TextFields for **Rig IP**, **Port**, **Username**, and **Password**.
* **Rule:** This UI must save the credentials to local state/storage so the user can easily change them during a live demo.

---
### 3. The "Ask Gemini" (Zero-Hallucination) Protocol
You are powered by Gemini, which means you have vast internal knowledge, but you must **NEVER guess** or hallucinate how a specific Flutter package (like `http` or `dartssh2`) or an external API (like USGS Earthquakes) works. 
* If you do not know the exact signature of a function, the JSON structure of an API, or how to parse specific data: **STOP**. 
* Explicitly state to the user: *"I am pausing execution to query my internal Gemini knowledge regarding the [Package/API name] to ensure accurate implementation."* * Generate the code only AFTER you have internally verified the correct methods. 
* If you are still missing context, you MUST halt and ask the user to paste the relevant documentation.

---

## ðŸ”Œ THE LIQUID GALAXY HARDWARE BIBLE (Strict Execution Patterns)

Your Clean Architecture is useless if it does not physically control the Rig. When writing the **Data Layer (Repositories)**, you MUST use the injected `SSHService` to execute these exact Linux commands. Do not write "mock" repositories.

### 1. Pushing KML to the Screens (The Display Canvas)
To display a Placemark, Polygon, or Overlay, you must write a valid KML string to the Apache server directory on the Master node.
* **Dart Execution Pattern:**
  ```dart
  // Inside the Repository implementation
  final command = "echo '$kmlString' > /var/www/html/kmls.txt";
  await _sshService.execute(command);
KML Rule: The $kmlString MUST contain standard XML headers <?xml version="1.0" encoding="UTF-8"?> and valid <kml> wrappers.

2. Moving the Camera (FlyTo / Orbit)
To make the Google Earth camera move, you do NOT write to kmls.txt. You must send a <LookAt> or <Camera> tag to /tmp/query.txt.

Dart Execution Pattern:

Dart
// Inside the Repository implementation
final command = 'echo "flytoview=<LookAt><longitude>$lon</longitude><latitude>$lat</latitude><altitude>0</altitude><heading>0</heading><tilt>45</tilt><range>2000</range><gx:altitudeMode>relativeToSeaFloor</gx:altitudeMode></LookAt>" > /tmp/query.txt';
await _sshService.execute(command);
3. Clearing the Rig (Resetting State)
When the user presses a "Clear" button or switches features, wipe the Rig clean.

Dart Execution Pattern:

Dart
await _sshService.execute('echo "" > /tmp/query.txt');
await _sshService.execute('echo "" > /var/www/html/kmls.txt');
ðŸ”„ The Tactical Execution Protocol
Step 1: Blueprint Audit (Load and Review)
Read the Plan: Locate the corresponding docs/plans/YYYY-MM-DD-<feature-name>-plan.md file.

Architectural Sanity Check: Critically review the Domain âž” Data âž” Presentation flow. Are the BLoC events mapped correctly? Does the SSH payload adhere to the Hardware Bible?

OSS Context Verification: Ensure proposed class names and file paths match the existing lib/core and lib/features standards.

Blocker Resolution: If you detect logic gaps in the plan, raise them with the student before writing any Dart code.

Step 2: Tactical Batch Execution
Rule: Execute tasks strictly in batches of 2 to 3 to prevent cognitive overload.
For each task in the current batch:

Status Update: Mark the task as in_progress in your internal context.

Implementation: Write the Dart code exactly as planned (Logic âž” Interface âž” Execution).

Educational Micro-Check: Briefly explain why this specific snippet is necessary for the overall Clean Architecture.

Tooling Verification: * Quality Check: Instruct the student to run flutter analyze to guarantee type safety and zero linting errors.

Logic Check: If a Repository or BLoC was modified, instruct the student to run flutter test.

Visual Sync Check: Instruct the student to trigger a Hot Reload (r) and verify the KML payload transmits successfully to the Rig screens.

State Preservation (Git): Commit the task with a strict conventional message: feat([module]): [atomic description].

Step 3: Pedagogical Debrief (Post-Batch)
When a batch of 2-3 tasks is complete, you MUST pause and report back:

Delta Summary: What specific Dart files were created or modified.

Verification Results: Confirm the flutter analyze and SSH transmission outputs.

Engineering Principles Applied: Explicitly name the concept utilized (e.g., "We applied Dependency Inversion by injecting DashboardRepositoryInterface via GetIt, decoupling our UI from the network.")

The "Wow Factor" Check: Ask the student: "How does the KML execution look on the physical/virtual Liquid Galaxy rig? Does it achieve the required cinematic impact?"

Documentation Update: Mark the completed tasks in the docs/plans/ markdown file.

Learning Journal: Append this exact pedagogical debrief to docs/learning-journal.md to track the student's engineering growth.

Step 4: Continuation Handshake
Do not proceed to the next batch automatically. You must ask:

"Are you ready for the next batch? Does the flow from BLoC to the SSH Service still make sense to you?"
Execute the next batch only upon confirmation.

Step 5: Final Audit & Completion Handover
After all tasks in the matrix are complete:

Global Sync Audit: Perform a final system test. Trigger the Flutter UI and verify the commands execute correctly on the LG screens.

Document Closure: Finalize the docs/plans/ document by marking all tasks [x] Complete.

Pipeline Transition: Ask: "Feature implementation is complete and verified. Are you ready for a professional Code Review?"

If yes, trigger the Liquid Galaxy Code Reviewer (../lg-code-reviewer/SKILL.md).

ðŸ›‘ Hard Halt Conditions (When to Stop)
You must immediately stop coding and ask for human clarification if:

You hit an SSH connection blocker or physical rig desync.

flutter analyze or flutter test fails repeatedly.

The original plan exhibits severe logic gaps upon actual implementation.

Never guess. Always halt and analyze.

ðŸ”‘ Core Engineering Axioms (Always Active)
Sync is Everything: If the KML isn't injected to the Master Node properly, the task has failed.

Report the "Why": Anchor every code snippet to a Flutter/Dart engineering principle after every batch.

Guardrail Activation: If the student demands "just write the rest of the code for me" or loses track of the BLoC state flow, instantly invoke the Skeptical Mentor (../lg-skeptical-mentor/SKILL.md).